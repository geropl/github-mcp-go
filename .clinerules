# GitHub MCP Go Project Rules

## Project Patterns

### Code Organization
- Go package structure follows standard Go conventions
- Tools are organized by GitHub resource type (repository, pulls, files, etc.)
- Each tool type has its own file in pkg/tools/
- Implementation details are in pkg/github/

### Naming Conventions
- Tool names use snake_case (e.g., create_pull_request)
- Go functions and methods use CamelCase
- Constants use UPPERCASE
- Test cases use descriptive names that indicate what's being tested

### Error Handling
- Custom error types in pkg/errors/
- GitHub API errors are converted to MCP-compatible errors
- Detailed error messages for troubleshooting
- Logging with logrus for context

## Testing Patterns

### Iterative Approach
- Focus on one test case at a time
- Make each test case work completely before moving to the next
- Start with "happy path" test cases before error cases
- Comment out test cases that aren't ready to be implemented yet

### Test Completion Rule
- Never mark a feature as complete until ALL its tests pass
- Verify each test case in normal mode before moving to the next
- Document any test limitations or TODOs in code comments

### Test Completion Checklist
Before marking any feature as complete:
1. ✓ All test cases are implemented in the test file
2. ✓ All test cases have been run with `-record` flag
3. ✓ All test cases have been run with `-golden` flag
4. ✓ All test cases pass in normal mode
5. ✓ Test directories exist in testdata/ for all test cases
6. ✓ Test status is updated in progress.md
7. ✓ Final verification is documented in activeContext.md

IMPORTANT: Never mark a feature as complete until ALL items in this checklist are verified.

### Test Verification Commands

For each test case, run the following commands in sequence:

1. Record HTTP interactions:
   ```bash
   go test -v ./pkg/tools -run TestCategory/TestCaseName -record
   ```

2. Create/update golden files:
   ```bash
   go test -v ./pkg/tools -run TestCategory/TestCaseName -golden
   ```

3. Verify test passes in normal mode:
   ```bash
   go test -v ./pkg/tools -run TestCategory/TestCaseName
   ```

4. Verify test directories exist:
   ```bash
   ls -la testdata/TestCategory/TestCaseName/
   ```

Example for list_workflow_jobs tool:
```bash
# Happy Path - ListWorkflowJobs
go test -v ./pkg/tools -run TestActions/ListWorkflowJobs -record
go test -v ./pkg/tools -run TestActions/ListWorkflowJobs -golden
go test -v ./pkg/tools -run TestActions/ListWorkflowJobs
ls -la testdata/TestActions/ListWorkflowJobs/

# Happy Path - ListWorkflowJobsWithFilter
go test -v ./pkg/tools -run TestActions/ListWorkflowJobsWithFilter -record
go test -v ./pkg/tools -run TestActions/ListWorkflowJobsWithFilter -golden
go test -v ./pkg/tools -run TestActions/ListWorkflowJobsWithFilter
ls -la testdata/TestActions/ListWorkflowJobsWithFilter/

# Error Cases
go test -v ./pkg/tools -run TestActions/ListWorkflowJobsInvalidOwner -record
go test -v ./pkg/tools -run TestActions/ListWorkflowJobsInvalidOwner -golden
go test -v ./pkg/tools -run TestActions/ListWorkflowJobsInvalidOwner
ls -la testdata/TestActions/ListWorkflowJobsInvalidOwner/

# (Repeat for all error cases)
```

### Test Verification Template

Copy this template to activeContext.md for each new tool implementation:

```markdown
### [tool_name] Tool Verification

[ ] All test cases are implemented in the test file
[ ] All test cases have been run with `-record` flag:
  - [ ] TestActions/[TestCase1] (run: `go test -v ./pkg/tools -run TestActions/[TestCase1] -record`)
  - [ ] TestActions/[TestCase2] (run: `go test -v ./pkg/tools -run TestActions/[TestCase2] -record`)
  - [ ] (Add all test cases)
[ ] All test cases have been run with `-golden` flag:
  - [ ] TestActions/[TestCase1] (run: `go test -v ./pkg/tools -run TestActions/[TestCase1] -golden`)
  - [ ] TestActions/[TestCase2] (run: `go test -v ./pkg/tools -run TestActions/[TestCase2] -golden`)
  - [ ] (Add all test cases)
[ ] All test cases pass in normal mode:
  - [ ] TestActions/[TestCase1] (run: `go test -v ./pkg/tools -run TestActions/[TestCase1]`)
  - [ ] TestActions/[TestCase2] (run: `go test -v ./pkg/tools -run TestActions/[TestCase2]`)
  - [ ] (Add all test cases)
[ ] Test directories exist in testdata/ for all test cases:
  - [ ] testdata/TestActions/[TestCase1] (verify: `ls -la testdata/TestActions/[TestCase1]/`)
  - [ ] testdata/TestActions/[TestCase2] (verify: `ls -la testdata/TestActions/[TestCase2]/`)
  - [ ] (Add all test cases)
[ ] Test status is updated in progress.md
[ ] Final verification is documented in activeContext.md

The tool has been fully implemented and tested according to the Test Completion Checklist.
```

### Test Structure
- Table-driven tests with TestCase structs
- Each test case has a Name, Tool, and Input
- Test cases are run in a loop with t.Run()
- RunTest function handles test execution and comparison

### VCR Usage
- Use -record flag to record new HTTP interactions
- Default to replay mode for deterministic testing
- Sanitize sensitive information in cassettes
- Cassettes are stored in testdata/cassette/

### Golden Files
- Use -golden flag to update golden files
- Golden files store expected test results in JSON format
- Golden files are stored in testdata/golden/
- Compare actual results against golden files during testing

## Development Workflow

### Implementation Order
1. Define tool schema and register with MCP server
2. Implement GitHub operations in pkg/github/
3. Implement tool handler in pkg/tools/
4. Add test cases in pkg/tools/*_test.go
5. For EACH test case:
   a. Run test with -record flag to create cassette
   b. Run test with -golden flag to create golden file
   c. Run test without flags to verify it passes
   d. Verify test directory exists in testdata/
6. Update progress.md with test status
7. Document verification in activeContext.md using the Test Verification Template

### Testing Workflow
1. Uncomment one test case at a time
2. Run test with -record flag to create cassette:
   ```bash
   go test -v ./pkg/tools -run TestCategory/TestCaseName -record
   ```
3. Run test with -golden flag to create golden file:
   ```bash
   go test -v ./pkg/tools -run TestCategory/TestCaseName -golden
   ```
4. Run test without flags to verify it passes:
   ```bash
   go test -v ./pkg/tools -run TestCategory/TestCaseName
   ```
5. Verify test directory exists:
   ```bash
   ls -la testdata/TestCategory/TestCaseName/
   ```
6. Check off the test case in the Test Verification Template in activeContext.md
7. Move to the next test case

## User Preferences

### Testing Focus
- Prefer thorough testing over quick implementation
- Take an iterative approach to testing
- Ensure each test case works completely before moving on
- Document test cases clearly

### Documentation
- Keep memory bank files up to date
- Document testing approach and progress
- Update progress.md with current status
- Update activeContext.md with current focus

### Memory Bank Management
- Be mindful of space in memory bank files
- Deleting irrelevant memories is a good thing
- Follow short-term vs. long-term memory strategy:
  - Short-term memory (activeContext.md, progress.md): Detailed, recent, specific
  - Long-term memory (systemPatterns.md, techContext.md, projectbrief.md): Compressed, patterns, principles
- Apply this strategy on every interaction with the memory bank
- Use "compress memory bank" trigger to perform a compression run
- When compressing memory bank files:
  1. Focus on patterns over instances
  2. Use tables and summaries instead of exhaustive lists
  3. Keep only the most relevant and recent information in short-term memory
  4. Distill important insights into long-term memory
  5. Delete outdated or redundant information
